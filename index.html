<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Publications</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">

<style>
body {
  font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont,
               "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.65;
  color: #222;
  margin: 0;
  padding: 0;
}

#controls {
  display: flex;
  gap: 1rem;
  margin-bottom: 2rem;
  flex-wrap: wrap;
}

#search, #yearFilter {
  padding: 0.65rem 0.75rem;
  font-size: 0.9rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-family: inherit;
}

#search { flex: 1; }

.year {
  font-size: 1.3rem;
  font-weight: 600;
  margin-top: 2.5rem;
  border-bottom: 1px solid #ddd;
  padding-bottom: 0.35rem;
}

.pub {
  margin: 0.85rem 0;
  font-size: 0.92rem;
}

.pub a {
  color: inherit;
  text-decoration: underline;
}

.loading {
  font-style: italic;
  color: #666;
}
</style>
</head>

<body>

<div id="controls">
  <input type="text" id="search" placeholder="Search publicationsâ€¦">
  <select id="yearFilter">
    <option value="all">All years</option>
  </select>
</div>

<div id="pubs" class="loading">Loading publicationsâ€¦</div>

<script>
const ORCIDS = [
  "0000-0002-5667-3293",
  "0000-0002-7382-1825",
  "0000-0003-0373-3720",
  "0000-0001-8466-8259",
  "0009-0008-1469-058X"
  // add more ORCIDs
];

async function fetchWorks(orcid) {
  const res = await fetch(`https://pub.orcid.org/v3.0/${orcid}/works`, {
    headers: { Accept: "application/json" }
  });
  return (await res.json()).group || [];
}

async function fetchWorkDetails(orcid, putCode) {
  const res = await fetch(`https://pub.orcid.org/v3.0/${orcid}/work/${putCode}`, {
    headers: { Accept: "application/json" }
  });
  return await res.json();
}

/* ---------- METADATA ---------- */
function getYear(w) {
  return w["publication-date"]?.year?.value || "n.d.";
}

function getDOI(w) {
  return w["external-ids"]?.["external-id"]
    ?.find(id => id["external-id-type"] === "doi")
    ?.["external-id-value"];
}

function extractContributors(w) {
  if (!w.contributors?.contributor?.length) return "";
  return w.contributors.contributor
    .map(c => c["credit-name"]?.value)
    .filter(Boolean)
    .join(", ");
}

/* ðŸ”‘ FALLBACK: extract authors from ORCID citation */
function extractAuthorsFromCitation(w) {
  const citation = w.citation?.citation?.value;
  if (!citation) return "";
  return citation.split("(")[0].trim();
}

/* ---------- FORMAT ---------- */
function formatCitation(w) {
  const year = getYear(w);
  const title = w.title?.title?.value || "Untitled";
  const journal = w["journal-title"]?.value || "";
  const doi = getDOI(w);

  let authors = extractContributors(w);
  if (!authors) {
    authors = extractAuthorsFromCitation(w);
  }

  let html = "";
  if (authors) html += `<strong>${authors}</strong> `;
  html += `(${year}). <strong>${title}</strong>. `;
  if (journal) html += `<em>${journal}</em>. `;
  if (doi) html += `<a href="https://doi.org/${doi}" target="_blank">https://doi.org/${doi}</a>`;
  return html;
}

/* ---------- LOAD ---------- */
let allPubs = [];

async function loadPublications() {
  let summaries = [];

  for (const orcid of ORCIDS) {
    const works = await fetchWorks(orcid);
    works.forEach(w => {
      const s = w["work-summary"][0];
      summaries.push({
        orcid,
        putCode: s["put-code"],
        title: s.title?.title?.value || ""
      });
    });
  }

  const seen = new Set();
  summaries = summaries.filter(w => {
    if (!w.title || seen.has(w.title)) return false;
    seen.add(w.title);
    return true;
  });

  for (const w of summaries) {
    const full = await fetchWorkDetails(w.orcid, w.putCode);
    allPubs.push(full);
  }

  allPubs.sort((a,b) => (parseInt(getYear(b))||0) - (parseInt(getYear(a))||0));
  populateYearFilter();
  render();
}

/* ---------- UI ---------- */
function populateYearFilter() {
  const years = [...new Set(allPubs.map(getYear))].filter(y=>y!=="n.d.").sort((a,b)=>b-a);
  const sel = document.getElementById("yearFilter");
  years.forEach(y => {
    const o = document.createElement("option");
    o.value = y;
    o.textContent = y;
    sel.appendChild(o);
  });
}

function render() {
  const q = document.getElementById("search").value.toLowerCase();
  const yf = document.getElementById("yearFilter").value;
  const c = document.getElementById("pubs");
  c.innerHTML = "";

  const filtered = allPubs.filter(w => {
    const t = formatCitation(w).toLowerCase();
    return t.includes(q) && (yf==="all" || getYear(w)===yf);
  });

  if (!filtered.length) {
    c.innerHTML = "<p class='loading'>No matching publications.</p>";
    return;
  }

  const byYear = {};
  filtered.forEach(w => {
    const y = getYear(w);
    byYear[y] ??= [];
    byYear[y].push(w);
  });

  Object.keys(byYear).sort((a,b)=>b-a).forEach(y => {
    const h = document.createElement("div");
    h.className = "year";
    h.textContent = y;
    c.appendChild(h);

    byYear[y].forEach(w => {
      const d = document.createElement("div");
      d.className = "pub";
      d.innerHTML = formatCitation(w);
      c.appendChild(d);
    });
  });
}

document.getElementById("search").addEventListener("input", render);
document.getElementById("yearFilter").addEventListener("change", render);

loadPublications();
</script>

</body>
</html>
